# 为什么要写单元测试      
      单元测试是开发者编写的一小段代码，用于检验目标代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试用于判断某个特定条件或特定场景下某个特定函数的行为。
   例如，用户可能把一个很大的值放入一个有序List中，然后确认该值出现在List 的尾部。或者，用户可能会从字符串中删除匹配某种模式的字符，然后确认字符串确实不再包含这些字符了。 
      单元测试是由程序员自己来完成，最终受益的也是程序员自己。可以这么说，程序员有责任编写功能代码，同时也就有责任为自己的代码编写单元测试。执行单元测试，就是为了证明这段代码的行为和我们期望的一致。 
   在一般情况下，一个功能模块往往会调用其他功能模块完成某项功能，如业务层的业务类可能会调用多个DAO完成某项业务。
   对某个功能模块进行单元测试时，我们希望屏蔽对外在功能模块的依赖，以便将焦点放在目标功能模块的测试上。
   这时模拟对象将是最有力的工具，它根据外在模块的接口模拟特定操作行为，这样单元测试就可以在假设关联模块正确工作的情况下验证本模块逻辑的正确性了.
    2.冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；
如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。
public static void main(String[] args) {
        //定义一个数组，长度为10
        int arr[] = new int[10];
        //随机生成0到20的随机数填充数组
        for(int i = 0;i<arr.length;i++){
            arr[i] =(int)( Math.random()*20);
        }
        //输出未排序前的数组
        for(int i = 0;i<arr.length;i++){
            System.out.print(arr[i]+" ");
        }
        //换行
        System.out.println();
        //进行冒泡排序
        for(int i =0;i<arr.length-1;i++)
            //第二层循环，最大的数排到数组底部
            for(int j = 0;j<arr.length-i-1;j++){
                if(arr[j]>arr[j+1]){
                    int temp;
                    temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        //输出查看结果
        for(int i = 0;i<arr.length;i++){
            System.out.print(arr[i]+" ");
        }
    }
